# 1.6 MCP Server Integration

## –°—Ç–∞—Ç—É—Å: üöß –ü–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ

## –û–ø–∏—Å–∞–Ω–∏–µ

–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è Electron overlay —Å MCP voice server —á–µ—Ä–µ–∑ Server-Sent Events (SSE) –¥–ª—è real-time —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ –≤–≤–æ–¥–∞ –º–µ–∂–¥—É overlay UI –∏ —Å–µ—Ä–≤–µ—Ä–æ–º. –ó–∞–º–µ–Ω—è–µ—Ç —Ç–µ–∫—É—â–∏–π polling –º–µ—Ö–∞–Ω–∏–∑–º –Ω–∞ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—É—é SSE –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—É —Å auto-reconnect –∏ exponential backoff.

## –ö–ª—é—á–µ–≤—ã–µ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏

- **SSE Client Implementation** (‚≠ê‚≠ê‚≠ê) - –†–µ–∞–ª–∏–∑–∞—Ü–∏—è EventSource –∫–ª–∏–µ–Ω—Ç–∞ —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π —Å–æ–±—ã—Ç–∏–π
- **Auto-Reconnect –º–µ—Ö–∞–Ω–∏–∑–º** (‚≠ê‚≠ê‚≠ê) - –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —Å exponential backoff
- **State Synchronization** (‚≠ê‚≠ê‚≠ê) - –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è voice state –º–µ–∂–¥—É server –∏ overlay
- **Event-Driven Architecture** (‚≠ê‚≠ê) - –ó–∞–º–µ–Ω–∞ polling –Ω–∞ event-driven –ø–æ–¥—Ö–æ–¥

## –ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏

- ‚úÖ Story 1.5 - Web Speech API Integration (–∑–∞–≤–µ—Ä—à–µ–Ω–æ)
- ‚úÖ SSE endpoint `/api/tts-events` (—Å—É—â–µ—Å—Ç–≤—É–µ—Ç –≤ unified-server.ts)

## –¢–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ

### –ß—Ç–æ —É–∂–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ

–í `unified-server.ts` —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç SSE –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–∞:

```typescript
// Server-Sent Events endpoint
app.get('/api/tts-events', (_req: Request, res: Response) => {
  res.writeHead(200, {
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache',
    'Connection': 'keep-alive',
  });

  res.write('data: {"type":"connected"}\n\n');
  ttsClients.add(res);

  res.on('close', () => {
    ttsClients.delete(res);
    // Auto-disable voice features when last client disconnects
  });
});
```

**–°—É—â–µ—Å—Ç–≤—É—é—â–∏–µ event types:**
- `connected` - –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ
- `speak` - TTS —Å–æ–±—ã—Ç–∏–µ (text-to-speech)
- `waitStatus` - Claude –æ–∂–∏–¥–∞–µ—Ç utterance (isWaiting: boolean)

### –ß—Ç–æ –Ω—É–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å

–í `electron/main/mcp-integration.ts` –µ—Å—Ç—å –∑–∞–≥–ª—É—à–∫–∞ —Å polling:

```typescript
export class MCPIntegration {
  private pollInterval: NodeJS.Timeout | null = null;
  private readonly POLL_INTERVAL_MS = 500; // 500ms polling

  // TODO: –ó–∞–º–µ–Ω–∏—Ç—å polling –Ω–∞ SSE
  private async getMockVoiceState(): Promise<VoiceState> {
    // Mock –¥–∞–Ω–Ω—ã–µ –¥–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏
  }
}
```

**–ó–∞–¥–∞—á–∞:** –ó–∞–º–µ–Ω–∏—Ç—å polling –Ω–∞ EventSource —Å auto-reconnect.

## –¢—Ä–µ–±–æ–≤–∞–Ω–∏—è

### 1. SSE Client Implementation

#### 1.1 EventSource Wrapper

```typescript
// electron/main/sse-client.ts
interface SSEClientConfig {
  url: string;
  reconnectDelay: number;      // Initial reconnect delay (ms)
  maxReconnectDelay: number;   // Max reconnect delay (ms)
  maxRetries: number;          // Max reconnect attempts (0 = infinite)
}

type SSEEventHandler = (data: any) => void;

export class SSEClient {
  private eventSource: EventSource | null = null;
  private config: SSEClientConfig;
  private reconnectAttempts = 0;
  private reconnectTimeout: NodeJS.Timeout | null = null;
  private eventHandlers = new Map<string, Set<SSEEventHandler>>();
  private isConnected = false;

  constructor(config: Partial<SSEClientConfig> = {}) {
    this.config = {
      url: config.url || 'http://localhost:5111/api/tts-events',
      reconnectDelay: config.reconnectDelay || 1000,
      maxReconnectDelay: config.maxReconnectDelay || 30000,
      maxRetries: config.maxRetries || 0 // 0 = infinite retries
    };
  }

  /**
   * –ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ SSE endpoint
   */
  connect(): void {
    if (this.eventSource) {
      console.warn('[SSE] Already connected');
      return;
    }

    console.log('[SSE] Connecting to', this.config.url);

    try {
      this.eventSource = new EventSource(this.config.url);

      this.eventSource.onopen = () => {
        console.log('[SSE] Connection established');
        this.isConnected = true;
        this.reconnectAttempts = 0; // Reset retry counter on success
        this.onConnectionChange?.(true);
      };

      this.eventSource.onmessage = (event) => {
        this.handleMessage(event);
      };

      this.eventSource.onerror = (error) => {
        console.error('[SSE] Connection error:', error);
        this.isConnected = false;
        this.onConnectionChange?.(false);

        // –ó–∞–∫—Ä—ã–≤–∞–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
        this.eventSource?.close();
        this.eventSource = null;

        // –ü—ã—Ç–∞–µ–º—Å—è –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è
        this.scheduleReconnect();
      };
    } catch (error) {
      console.error('[SSE] Failed to create EventSource:', error);
      this.scheduleReconnect();
    }
  }

  /**
   * –û—Ç–∫–ª—é—á–∏—Ç—å—Å—è –æ—Ç SSE endpoint
   */
  disconnect(): void {
    if (this.reconnectTimeout) {
      clearTimeout(this.reconnectTimeout);
      this.reconnectTimeout = null;
    }

    if (this.eventSource) {
      this.eventSource.close();
      this.eventSource = null;
      this.isConnected = false;
      console.log('[SSE] Disconnected');
      this.onConnectionChange?.(false);
    }
  }

  /**
   * –ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ —Å–æ–±—ã—Ç–∏–µ
   */
  on(eventType: string, handler: SSEEventHandler): void {
    if (!this.eventHandlers.has(eventType)) {
      this.eventHandlers.set(eventType, new Set());
    }
    this.eventHandlers.get(eventType)!.add(handler);
  }

  /**
   * –û—Ç–ø–∏—Å–∞—Ç—å—Å—è –æ—Ç —Å–æ–±—ã—Ç–∏—è
   */
  off(eventType: string, handler: SSEEventHandler): void {
    const handlers = this.eventHandlers.get(eventType);
    if (handlers) {
      handlers.delete(handler);
      if (handlers.size === 0) {
        this.eventHandlers.delete(eventType);
      }
    }
  }

  /**
   * –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
   */
  isConnectionActive(): boolean {
    return this.isConnected;
  }

  /**
   * –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Ö–æ–¥—è—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
   */
  private handleMessage(event: MessageEvent): void {
    try {
      const data = JSON.parse(event.data);
      const eventType = data.type;

      if (!eventType) {
        console.warn('[SSE] Received event without type:', data);
        return;
      }

      console.log('[SSE] Event received:', eventType, data);

      // –í—ã–∑—ã–≤–∞–µ–º –≤—Å–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è —ç—Ç–æ–≥–æ —Ç–∏–ø–∞ —Å–æ–±—ã—Ç–∏—è
      const handlers = this.eventHandlers.get(eventType);
      if (handlers) {
        handlers.forEach(handler => {
          try {
            handler(data);
          } catch (error) {
            console.error(`[SSE] Error in handler for ${eventType}:`, error);
          }
        });
      }
    } catch (error) {
      console.error('[SSE] Failed to parse message:', error);
    }
  }

  /**
   * –ü–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è —Å exponential backoff
   */
  private scheduleReconnect(): void {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ª–∏–º–∏—Ç –ø–æ–ø—ã—Ç–æ–∫ (0 = infinite)
    if (this.config.maxRetries > 0 && this.reconnectAttempts >= this.config.maxRetries) {
      console.error('[SSE] Max reconnect attempts reached');
      this.onMaxRetriesReached?.();
      return;
    }

    this.reconnectAttempts++;

    // Exponential backoff: delay * (2 ^ attempts)
    const delay = Math.min(
      this.config.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1),
      this.config.maxReconnectDelay
    );

    console.log(
      `[SSE] Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts}${
        this.config.maxRetries > 0 ? `/${this.config.maxRetries}` : ''
      })`
    );

    this.reconnectTimeout = setTimeout(() => {
      this.reconnectTimeout = null;
      this.connect();
    }, delay);
  }

  // Event callbacks
  onConnectionChange?: (connected: boolean) => void;
  onMaxRetriesReached?: () => void;
}
```

### 2. –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ MCPIntegration

#### 2.1 –ó–∞–º–µ–Ω–∞ Polling –Ω–∞ SSE

```typescript
// electron/main/mcp-integration.ts
import { BrowserWindow } from 'electron';
import { SSEClient } from './sse-client';
import type { VoiceState } from '../preload/types';

interface WaitStatusEvent {
  type: 'waitStatus';
  isWaiting: boolean;
}

interface SpeakEvent {
  type: 'speak';
  text: string;
}

interface ConnectedEvent {
  type: 'connected';
}

type SSEEvent = WaitStatusEvent | SpeakEvent | ConnectedEvent;

export class MCPIntegration {
  private window: BrowserWindow;
  private sseClient: SSEClient;
  private currentState: VoiceState;

  constructor(window: BrowserWindow, serverUrl: string = 'http://localhost:5111') {
    this.window = window;
    this.currentState = {
      state: 'idle',
      timestamp: Date.now()
    };

    // –°–æ–∑–¥–∞—ë–º SSE –∫–ª–∏–µ–Ω—Ç
    this.sseClient = new SSEClient({
      url: `${serverUrl}/api/tts-events`,
      reconnectDelay: 1000,        // 1s initial delay
      maxReconnectDelay: 30000,    // 30s max delay
      maxRetries: 0                // Infinite retries
    });

    this.setupSSEHandlers();
  }

  /**
   * –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ SSE —Å–æ–±—ã—Ç–∏–π
   */
  private setupSSEHandlers(): void {
    // Handler: connected
    this.sseClient.on('connected', () => {
      console.log('[MCP] Connected to voice server');
      this.updateState('idle');
    });

    // Handler: waitStatus
    this.sseClient.on('waitStatus', (data: WaitStatusEvent) => {
      console.log('[MCP] Wait status changed:', data.isWaiting);

      if (data.isWaiting) {
        this.updateState('listening', {
          metadata: {
            isWaiting: true,
            waitMessage: 'Claude is waiting for your voice input...'
          }
        });
      } else {
        this.updateState('idle');
      }
    });

    // Handler: speak (TTS events)
    this.sseClient.on('speak', (data: SpeakEvent) => {
      console.log('[MCP] Speak event:', data.text);

      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ renderer –¥–ª—è –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è TTS
      this.notifyRenderer({
        state: 'processing',
        timestamp: Date.now(),
        metadata: {
          ttsText: data.text
        }
      });
    });

    // Connection state handlers
    this.sseClient.onConnectionChange = (connected: boolean) => {
      if (connected) {
        console.log('[MCP] SSE connection established');
        this.updateState('idle');
      } else {
        console.warn('[MCP] SSE connection lost');
        this.updateState('error', {
          metadata: {
            errorMessage: 'Connection to MCP server lost'
          }
        });
      }
    };

    this.sseClient.onMaxRetriesReached = () => {
      console.error('[MCP] Failed to reconnect to MCP server');
      this.updateState('error', {
        metadata: {
          errorMessage: 'Cannot connect to MCP server'
        }
      });
    };
  }

  /**
   * –ù–∞—á–∏–Ω–∞–µ—Ç SSE –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ
   */
  start(): void {
    console.log('[MCP] Starting MCP integration (SSE mode)');
    this.sseClient.connect();
  }

  /**
   * –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç SSE –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ
   */
  stop(): void {
    console.log('[MCP] Stopping MCP integration');
    this.sseClient.disconnect();
  }

  /**
   * –ü–æ–ª—É—á–∞–µ—Ç —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
   */
  getCurrentState(): VoiceState {
    return this.currentState;
  }

  /**
   * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å MCP server
   */
  isServerConnected(): boolean {
    return this.sseClient.isConnectionActive();
  }

  /**
   * –û–±–Ω–æ–≤–ª—è–µ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏ —É–≤–µ–¥–æ–º–ª—è–µ—Ç renderer
   */
  private updateState(state: VoiceState['state'], updates: Partial<VoiceState> = {}): void {
    const newState: VoiceState = {
      state,
      timestamp: Date.now(),
      ...updates
    };

    // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–∑–º–µ–Ω–∏–ª–æ—Å—å
    if (newState.state !== this.currentState.state) {
      this.currentState = newState;
      this.notifyRenderer(newState);
    }
  }

  /**
   * –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –≤ renderer process
   */
  private notifyRenderer(state: VoiceState): void {
    if (this.window && !this.window.isDestroyed()) {
      this.window.webContents.send('voice:state-changed', state);
      console.log('[MCP] Voice state changed:', state.state);
    }
  }
}
```

### 3. Renderer Integration

#### 3.1 –û–±—Ä–∞–±–æ—Ç–∫–∞ SSE —Å–æ–±—ã—Ç–∏–π –≤ Renderer

```typescript
// electron/renderer/main.ts
import { MCPClient } from '../main/mcp-client';
import { SpeechManager } from './speech/speech-manager';
import { SpeechUI } from './speech/speech-ui';
import { StateIndicator } from './components/StateIndicator';
import type { VoiceState } from '../preload/types';

// Initialize components
const stateIndicator = new StateIndicator();
const speechUI = new SpeechUI(stateIndicator);
const mcpClient = new MCPClient(5111);
const speechManager = new SpeechManager(mcpClient, speechUI);

// Listen for voice state changes from main process (SSE events)
window.electron.onVoiceStateChanged((state: VoiceState) => {
  console.log('[Renderer] Voice state changed:', state);

  // Update UI based on state
  switch (state.state) {
    case 'idle':
      stateIndicator.setState('idle');
      break;

    case 'listening':
      if (state.metadata?.isWaiting) {
        // Claude is waiting for utterance
        stateIndicator.setState('listening', {
          statusText: state.metadata.waitMessage || 'Claude is listening...'
        });
      }
      break;

    case 'processing':
      if (state.metadata?.ttsText) {
        // TTS event received - –≤–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º —Ç–µ–∫—Å—Ç
        playTTS(state.metadata.ttsText);
      }
      stateIndicator.setState('processing');
      break;

    case 'error':
      stateIndicator.setState('error', {
        errorMessage: state.metadata?.errorMessage || 'Connection error'
      });
      break;
  }
});

// TTS playback function (–µ—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è browser TTS)
function playTTS(text: string): void {
  const utterance = new SpeechSynthesisUtterance(text);
  utterance.lang = 'ru-RU';
  window.speechSynthesis.speak(utterance);
}
```

### 4. Preload Script Updates

```typescript
// electron/preload/index.ts
import { contextBridge, ipcRenderer } from 'electron';
import type { VoiceState } from './types';

contextBridge.exposeInMainWorld('electron', {
  // Existing methods...

  // SSE event listener
  onVoiceStateChanged: (callback: (state: VoiceState) => void) => {
    ipcRenderer.on('voice:state-changed', (_event, state: VoiceState) => {
      callback(state);
    });
  }
});
```

### 5. Main Process Integration

```typescript
// electron/main/index.ts
import { app, BrowserWindow } from 'electron';
import { WindowManager } from './window-manager';
import { MCPIntegration } from './mcp-integration';

let mainWindow: BrowserWindow | null = null;
let mcpIntegration: MCPIntegration | null = null;

function createWindow() {
  const windowManager = new WindowManager();
  mainWindow = windowManager.getWindow();

  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º MCP –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—é
  const serverUrl = process.env.MCP_VOICE_HOOKS_URL || 'http://localhost:5111';
  mcpIntegration = new MCPIntegration(mainWindow, serverUrl);

  // –ó–∞–ø—É—Å–∫–∞–µ–º SSE –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ
  mcpIntegration.start();

  mainWindow.on('closed', () => {
    // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º MCP –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—é –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ –æ–∫–Ω–∞
    mcpIntegration?.stop();
    mcpIntegration = null;
    mainWindow = null;
  });
}

app.whenReady().then(createWindow);

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// Graceful shutdown
app.on('before-quit', () => {
  mcpIntegration?.stop();
});
```

## –§–∞–π–ª–æ–≤–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞

```
electron/
‚îú‚îÄ‚îÄ main/
‚îÇ   ‚îú‚îÄ‚îÄ index.ts                      # (modified) Add MCP integration
‚îÇ   ‚îú‚îÄ‚îÄ mcp-client.ts                 # (existing) HTTP client
‚îÇ   ‚îú‚îÄ‚îÄ mcp-integration.ts            # (modified) Replace polling with SSE
‚îÇ   ‚îî‚îÄ‚îÄ sse-client.ts                 # (new) EventSource wrapper
‚îú‚îÄ‚îÄ renderer/
‚îÇ   ‚îî‚îÄ‚îÄ main.ts                       # (modified) Handle SSE events
‚îî‚îÄ‚îÄ preload/
    ‚îî‚îÄ‚îÄ index.ts                      # (modified) Expose SSE events to renderer
```

## –ö—Ä–∏—Ç–µ—Ä–∏–∏ –ø—Ä–∏–µ–º–∫–∏

- [ ] SSEClient —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω —Å auto-reconnect –∏ exponential backoff
- [ ] MCPIntegration –∑–∞–º–µ–Ω—ë–Ω —Å polling –Ω–∞ SSE
- [ ] –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Å–µ—Ö —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö event types (connected, speak, waitStatus)
- [ ] Auto-reconnect —Ä–∞–±–æ—Ç–∞–µ—Ç –ø—Ä–∏ –ø–æ—Ç–µ—Ä–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
- [ ] Exponential backoff: 1s, 2s, 4s, 8s, 16s, 30s (max)
- [ ] State synchronization –º–µ–∂–¥—É server –∏ overlay UI
- [ ] Graceful shutdown –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ overlay
- [ ] Error handling –¥–ª—è network failures
- [ ] Unit —Ç–µ—Å—Ç—ã –¥–ª—è SSEClient
- [ ] Integration —Ç–µ—Å—Ç—ã –¥–ª—è MCPIntegration

## –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞ SSE –Ω–∞–¥ Polling

### –¢–µ–∫—É—â–∏–π –ø–æ–¥—Ö–æ–¥ (Polling)
```typescript
// 500ms polling interval
setInterval(() => {
  fetchVoiceState(); // HTTP request –∫–∞–∂–¥—ã–µ 500ms
}, 500);
```

**–ü—Ä–æ–±–ª–µ–º—ã:**
- ‚ùå –í—ã—Å–æ–∫–∞—è latency (–¥–æ 500ms)
- ‚ùå –ò–∑–±—ã—Ç–æ—á–Ω—ã–π —Ç—Ä–∞—Ñ–∏–∫ (–¥–∞–∂–µ –∫–æ–≥–¥–∞ –Ω–µ—Ç –∏–∑–º–µ–Ω–µ–Ω–∏–π)
- ‚ùå –ù–∞–≥—Ä—É–∑–∫–∞ –Ω–∞ server

### –ù–æ–≤—ã–π –ø–æ–¥—Ö–æ–¥ (SSE)
```typescript
// Real-time event stream
eventSource.onmessage = (event) => {
  updateState(event.data); // –ú–≥–Ω–æ–≤–µ–Ω–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ
};
```

**–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:**
- ‚úÖ Low latency (~10-50ms)
- ‚úÖ –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ç—Ä–∞—Ñ–∏–∫ (—Ç–æ–ª—å–∫–æ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è—Ö)
- ‚úÖ Efficient –¥–ª—è server

## –°–ª–µ–¥—É—é—â–∏–µ —à–∞–≥–∏ (Story 1.7)

–ü–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è Story 1.6:
1. Settings Panel - —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ (—è–∑—ã–∫, sensitivity, auto-reconnect config)
2. Keyboard Shortcuts - —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —á–µ—Ä–µ–∑ –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É
3. System Tray Integration

## –†–∏—Å–∫–∏ –∏ –º–∏—Ç–∏–≥–∞—Ü–∏—è

### –†–∏—Å–∫ 1: EventSource –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç –≤ Electron
**–ü—Ä–æ–±–ª–µ–º–∞:** Electron –º–æ–∂–µ—Ç –∏–º–µ—Ç—å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è —Å EventSource API

**–ú–∏—Ç–∏–≥–∞—Ü–∏—è:**
- –¢–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –Ω–∞ —Ä–∞–Ω–Ω–∏—Ö —ç—Ç–∞–ø–∞—Ö
- Fallback –Ω–∞ WebSocket –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏
- –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å polyfill –µ—Å–ª–∏ –Ω—É–∂–Ω–æ

### –†–∏—Å–∫ 2: Reconnect loop –ø—Ä–∏ server restart
**–ü—Ä–æ–±–ª–µ–º–∞:** –ë–µ—Å–∫–æ–Ω–µ—á–Ω—ã–µ –ø–æ–ø—ã—Ç–∫–∏ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –ø—Ä–∏ –≤—ã–∫–ª—é—á–µ–Ω–Ω–æ–º server

**–ú–∏—Ç–∏–≥–∞—Ü–∏—è:**
- Exponential backoff (1s ‚Üí 30s)
- Visual indicator –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (connection status)
- –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å manual reconnect

### –†–∏—Å–∫ 3: Memory leaks –ø—Ä–∏ –º–Ω–æ–≥–æ–∫—Ä–∞—Ç–Ω—ã—Ö reconnect
**–ü—Ä–æ–±–ª–µ–º–∞:** EventSource –æ–±—ä–µ–∫—Ç—ã –º–æ–≥—É—Ç –Ω–µ –æ—á–∏—â–∞—Ç—å—Å—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ

**–ú–∏—Ç–∏–≥–∞—Ü–∏—è:**
- –Ø–≤–Ω—ã–π –≤—ã–∑–æ–≤ `eventSource.close()` –ø–µ—Ä–µ–¥ reconnect
- Cleanup –≤ `disconnect()` –º–µ—Ç–æ–¥–µ
- Event listener cleanup –ø—Ä–∏ unmount

## –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ

### Unit Tests

```typescript
// electron/main/__tests__/sse-client.test.ts
describe('SSEClient', () => {
  it('should connect to SSE endpoint', () => {
    const client = new SSEClient({ url: 'http://localhost:5111/api/tts-events' });
    client.connect();
    expect(client.isConnectionActive()).toBe(true);
  });

  it('should handle reconnect with exponential backoff', async () => {
    const client = new SSEClient({
      reconnectDelay: 100,
      maxReconnectDelay: 1000
    });

    // Simulate connection error
    client.connect();
    // Trigger error...

    // Check retry delays: 100ms, 200ms, 400ms, 800ms, 1000ms
  });

  it('should call event handlers', () => {
    const client = new SSEClient();
    const handler = jest.fn();

    client.on('waitStatus', handler);
    // Simulate event...

    expect(handler).toHaveBeenCalled();
  });
});
```

### Integration Tests

```bash
# Development
npm run electron:dev

# Unit tests
npm test -- --testPathPattern=sse-client

# Integration tests
npm test -- --testPathPattern=mcp-integration
```

## Environment Variables

```bash
# MCP Server URL (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
export MCP_VOICE_HOOKS_URL=http://localhost:5111

# SSE reconnect configuration (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
export MCP_SSE_RECONNECT_DELAY=1000
export MCP_SSE_MAX_RECONNECT_DELAY=30000
export MCP_SSE_MAX_RETRIES=0  # 0 = infinite
```

## Migration Plan

### Phase 1: Implement SSEClient (1 –¥–µ–Ω—å)
- [ ] –°–æ–∑–¥–∞—Ç—å `sse-client.ts`
- [ ] Unit —Ç–µ—Å—Ç—ã –¥–ª—è SSEClient
- [ ] Exponential backoff logic

### Phase 2: Update MCPIntegration (1 –¥–µ–Ω—å)
- [ ] –ó–∞–º–µ–Ω–∏—Ç—å polling –Ω–∞ SSE –≤ `mcp-integration.ts`
- [ ] –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Å–µ—Ö event types
- [ ] Error handling

### Phase 3: Renderer Integration (1 –¥–µ–Ω—å)
- [ ] –û–±–Ω–æ–≤–∏—Ç—å preload script
- [ ] –û–±—Ä–∞–±–æ—Ç–∫–∞ SSE events –≤ renderer
- [ ] UI updates

### Phase 4: Testing & Polish (1-2 –¥–Ω—è)
- [ ] Integration —Ç–µ—Å—Ç—ã
- [ ] Manual testing
- [ ] Performance validation
- [ ] Documentation

**Total:** 3-5 –¥–Ω–µ–π
