# 1.2 Window Manager & Overlay

## Статус: ✅ Завершено

## Описание

Реализация Window Manager для управления overlay окном с поддержкой click-through, drag & drop позиционирования и кросс-платформенной совместимости.

## Ключевые сложности

- **Click-through с cursor polling** (⭐⭐⭐⭐) - Необходимо реализовать логику переключения между click-through и нормальным режимом на основе положения курсора
- **Кросс-платформенные различия always-on-top** (⭐⭐⭐) - Разное поведение на Windows, macOS, Linux
- **Drag & drop функциональность** (⭐⭐⭐⭐) - Перетаскивание окна без frame при одновременной работе click-through

## Зависимости

- ✅ Story 1.1 - Electron Project Setup (завершено)

## Требования

### 1. Window Manager (Main Process)

#### 1.1 Управление позицией окна
- [x] Сохранение позиции окна в конфигурации
- [x] Восстановление позиции при запуске
- [x] Валидация позиции (не за пределами экрана)

#### 1.2 Управление видимостью
- [x] Показать/скрыть окно (через IPC)
- [ ] Анимация появления/исчезновения (отложено)
- [x] Состояние видимости в конфигурации

#### 1.3 Always-on-top управление
- [x] Включить/выключить always-on-top
- [x] Кросс-платформенная реализация (Windows forward option)
- [x] Обработка edge cases для каждой платформы

### 2. Click-through с Cursor Polling

#### 2.1 Определение hover состояния
- [x] Polling позиции курсора (интервал 50ms)
- [x] Проверка: курсор над окном overlay
- [x] Проверка: курсор над интерактивными элементами

#### 2.2 Переключение режимов
- [x] `setIgnoreMouseEvents(true)` - когда курсор НЕ над интерактивными элементами
- [x] `setIgnoreMouseEvents(false)` - когда курсор над интерактивными элементами
- [x] Smooth transitions (предотвращение flickering через кэширование состояния)

#### 2.3 Определение интерактивных зон
Renderer должен отправлять в main process координаты интерактивных элементов:
- [x] IPC канал: `renderer -> main` с координатами элементов
- [x] Обновление при изменении layout (MutationObserver)
- [x] Debouncing обновлений (100ms)

### 3. Drag & Drop позиционирование

#### 3.1 Renderer логика
- [x] Обработка `mousedown` на drag handle элементе
- [x] Отправка события start drag в main process
- [x] Расчет offset от начальной позиции

#### 3.2 Main Process логика
- [x] IPC handler для `start-drag` события
- [x] Отключение click-through на время drag
- [x] Обновление позиции окна в реальном времени
- [x] Сохранение финальной позиции при `mouseup`
- [x] Включение click-through обратно после drag

#### 3.3 Валидация позиции
- [x] Ограничение перемещения границами экрана
- [ ] Snap-to-edge функциональность (отложено)
- [x] Multi-monitor поддержка

### 4. IPC API

#### 4.1 Main -> Renderer
```typescript
// Отправка состояния окна в renderer
{
  type: 'window-state-changed',
  payload: {
    position: { x: number, y: number },
    visible: boolean,
    alwaysOnTop: boolean
  }
}
```

#### 4.2 Renderer -> Main
```typescript
// Управление окном
interface WindowAPI {
  setPosition(x: number, y: number): Promise<void>;
  setVisible(visible: boolean): Promise<void>;
  setAlwaysOnTop(alwaysOnTop: boolean): Promise<void>;

  // Drag & drop
  startDrag(offsetX: number, offsetY: number): Promise<void>;
  updateDragPosition(screenX: number, screenY: number): Promise<void>;
  endDrag(): Promise<void>;

  // Интерактивные зоны
  updateInteractiveRegions(regions: Array<{x: number, y: number, width: number, height: number}>): Promise<void>;
}
```

### 5. Конфигурация

#### 5.1 Сохранение настроек
Файл: `~/.mcp-voice-hooks/electron-config.json`
```json
{
  "window": {
    "position": { "x": 100, "y": 100 },
    "visible": true,
    "alwaysOnTop": true
  }
}
```

#### 5.2 Defaults
- Position: Правый верхний угол экрана (с отступом 20px)
- Visible: true
- AlwaysOnTop: true

### 6. Renderer UI

#### 6.1 Drag Handle
- [x] Элемент для перетаскивания (header с иконкой drag dots)
- [x] Визуальная индикация draggable области
- [x] Cursor: grab / grabbing

#### 6.2 Interactive Elements
- [x] Кнопки управления (pin/unpin)
- [ ] Minimize, settings (отложено для Story 1.3)
- [x] Все элементы в интерактивных зонах

#### 6.3 Стили
- [x] Прозрачность фона для non-interactive зон
- [x] Backdrop filter для overlay эффекта
- [x] Hover states для интерактивных элементов

### 7. Тестирование

#### 7.1 Unit тесты (Main Process)
- [x] Window Manager: сохранение/загрузка позиции
- [x] Click-through logic: переключение режимов
- [x] Drag & drop: валидация позиции

#### 7.2 Integration тесты
- [x] IPC communication между main и renderer (в unit тестах)
- [x] Cursor polling механизм
- [x] Drag & drop полный workflow

#### 7.3 Кросс-платформенное тестирование
- [x] Windows: Always-on-top, click-through (forward option)
- [ ] macOS: Always-on-top, click-through, permission handling (требуется реальное тестирование)
- [ ] Linux (опционально): Always-on-top, click-through (требуется реальное тестирование)

## Архитектура

```
┌─────────────────────────────────────────────────────────────┐
│                    Window Manager                            │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌──────────────────┐         ┌──────────────────┐          │
│  │   Main Process   │◄───────►│  Renderer Process│          │
│  │                  │   IPC   │                  │          │
│  │ • Position Mgmt  │         │ • Drag Handle    │          │
│  │ • Visibility     │         │ • Interactive UI │          │
│  │ • Click-through  │         │ • Region Tracker │          │
│  │ • Cursor Polling │         │                  │          │
│  └──────────────────┘         └──────────────────┘          │
│           │                              │                   │
│           ▼                              ▼                   │
│  ┌──────────────────┐         ┌──────────────────┐          │
│  │ Config Manager   │         │  DOM / CSS       │          │
│  │ (JSON storage)   │         │  (Overlay styles)│          │
│  └──────────────────┘         └──────────────────┘          │
│                                                               │
└─────────────────────────────────────────────────────────────┘

Cursor Polling Flow:
┌─────────────┐
│ Every 50ms  │
└──────┬──────┘
       │
       ▼
┌─────────────────────────┐      Yes    ┌──────────────────────┐
│ Cursor over window?     │────────────►│ setIgnoreMouseEvents │
└─────────────────────────┘             │ (false)              │
       │ No                              └──────────────────────┘
       ▼
┌─────────────────────────┐
│ setIgnoreMouseEvents    │
│ (true)                  │
└─────────────────────────┘

Drag & Drop Flow:
Renderer:                     Main Process:
┌─────────────┐
│ mousedown   │──────────────►┌─────────────────────┐
│ on handle   │  startDrag()  │ Disable click-through│
└─────────────┘               └─────────────────────┘
       │
       ▼
┌─────────────┐
│ mousemove   │──────────────►┌─────────────────────┐
│ (dragging)  │  updatePos()  │ Update window pos   │
└─────────────┘               └─────────────────────┘
       │
       ▼
┌─────────────┐
│ mouseup     │──────────────►┌─────────────────────┐
│ (drop)      │  endDrag()    │ Enable click-through│
└─────────────┘               │ Save position       │
                               └─────────────────────┘
```

## Технические детали

### Cursor Polling Implementation

```typescript
// main/window-manager.ts
class WindowManager {
  private cursorPollInterval: NodeJS.Timeout | null = null;
  private interactiveRegions: Array<{x: number, y: number, width: number, height: number}> = [];

  startCursorPolling() {
    this.cursorPollInterval = setInterval(() => {
      const cursorPos = screen.getCursorScreenPoint();
      const windowBounds = this.window.getBounds();

      // Проверка: курсор над окном?
      const isOverWindow =
        cursorPos.x >= windowBounds.x &&
        cursorPos.x <= windowBounds.x + windowBounds.width &&
        cursorPos.y >= windowBounds.y &&
        cursorPos.y <= windowBounds.y + windowBounds.height;

      if (!isOverWindow) {
        this.window.setIgnoreMouseEvents(true);
        return;
      }

      // Проверка: курсор над интерактивным элементом?
      const relativeX = cursorPos.x - windowBounds.x;
      const relativeY = cursorPos.y - windowBounds.y;

      const isOverInteractive = this.interactiveRegions.some(region =>
        relativeX >= region.x &&
        relativeX <= region.x + region.width &&
        relativeY >= region.y &&
        relativeY <= region.y + region.height
      );

      this.window.setIgnoreMouseEvents(!isOverInteractive);
    }, 50); // 50ms = 20 fps
  }
}
```

### Platform-specific Considerations

#### macOS
- `alwaysOnTop` работает стабильно
- Может требоваться разрешение Accessibility для cursor tracking
- `setIgnoreMouseEvents` работает хорошо

#### Windows
- `alwaysOnTop` может конфликтовать с некоторыми окнами (fullscreen games)
- `setIgnoreMouseEvents` требует `forward` опцию для правильной работы:
  ```typescript
  window.setIgnoreMouseEvents(true, { forward: true })
  ```

#### Linux
- `alwaysOnTop` зависит от window manager (GNOME, KDE, etc.)
- Click-through поддержка может быть ограничена
- Требуется тестирование на разных дистрибутивах

## Риски и митигация

### Риск 1: Performance issues с cursor polling
**Митигация:**
- Начать с 50ms интервала, профилировать
- Можно увеличить до 100ms если performance проблема
- Оптимизировать расчеты интерактивных зон

### Риск 2: Flickering при переключении click-through
**Митигация:**
- Добавить debouncing (минимальное время между переключениями)
- Кэшировать последнее состояние и избегать лишних вызовов

### Риск 3: Проблемы с multi-monitor setup
**Митигация:**
- Использовать `screen.getCursorScreenPoint()` вместо относительных координат
- Валидация позиции окна при изменении конфигурации мониторов
- Обработка события `display-added`/`display-removed`

## Выполненные задачи

### Основные компоненты
- ✅ **WindowManager класс** - полноценная система управления окном с cursor polling
- ✅ **IPC Bridge** - type-safe API через contextBridge для renderer ↔ main communication
- ✅ **Renderer UI** - современный overlay дизайн с drag handle и controls
- ✅ **Config Persistence** - сохранение и восстановление состояния окна
- ✅ **Unit тесты** - покрытие основных сценариев WindowManager

### Ключевые функции
- ✅ Cursor polling (50ms интервал) для click-through
- ✅ Drag & drop с автоматическим отключением click-through
- ✅ Валидация позиции окна (multi-monitor support)
- ✅ Windows-specific optimizations (forward: true для setIgnoreMouseEvents)
- ✅ MutationObserver для автоматического обновления интерактивных зон
- ✅ Debouncing updates (100ms) для производительности

### Файлы
- `electron/main/window-manager.ts` - основной класс WindowManager
- `electron/main/window-manager.test.ts` - unit тесты
- `electron/main/index.ts` - интеграция WindowManager в main process
- `electron/preload/types.ts` - TypeScript типы для Window API
- `electron/preload/index.ts` - contextBridge expose Window API
- `electron/renderer/main.ts` - drag & drop логика и region tracking
- `electron/renderer/index.html` - overlay UI structure
- `electron/renderer/styles.css` - современные стили с backdrop-filter

## Следующие шаги (Story 1.3)

После завершения Story 1.2:
1. Интеграция с MCP server для получения utterances
2. UI для отображения статуса listening/speaking
3. Voice input visualization

## Команды для работы

```bash
# Development с hot reload
npm run electron:dev

# Build production
npm run electron:build

# Тестирование
npm test -- --testPathPattern=window-manager
```

## Ссылки

- [Electron BrowserWindow API](https://www.electronjs.org/docs/latest/api/browser-window)
- [Electron Screen API](https://www.electronjs.org/docs/latest/api/screen)
- [setIgnoreMouseEvents](https://www.electronjs.org/docs/latest/api/browser-window#winsetignoremouseeventsignore-options)
- [IPC Main/Renderer Communication](https://www.electronjs.org/docs/latest/tutorial/ipc)
