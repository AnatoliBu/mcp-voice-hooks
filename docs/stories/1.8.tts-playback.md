# Story 1.8: TTS Playback

## Цель
Интегрировать macOS `say` command для воспроизведения голосовых ответов Claude через системный TTS, с управлением очередью, дедупликацией голосов (browser + system) и автоматической паузой микрофона во время воспроизведения.

## Контекст
- **Зависимости:** Story 1.6 (MCP Server Integration), Story 1.7 (Settings Panel)
- **Effort:** M (3-5 дней)
- **Сложность:** ⭐⭐⭐ (3/5)

## Проблемы, которые решаем

### 1. Voice Deduplication
**Проблема:** В текущей системе есть два источника TTS:
- Browser TTS (через Web Speech API)
- System TTS (через macOS `say` command)

Оба могут получать одни и те же события от MCP server, что приводит к дублированию голосового вывода.

**Решение:** Unified voice selection в Settings Panel. Пользователь выбирает один голос, и только соответствующий TTS engine активируется.

### 2. TTS Queue Management
**Проблема:** Множественные TTS события могут приходить одновременно (например, Claude отвечает несколькими сообщениями подряд). Без очереди голоса будут накладываться друг на друга.

**Решение:** FIFO очередь для TTS событий с последовательным воспроизведением.

### 3. Microphone Pause During TTS
**Проблема:** Если микрофон активен во время TTS воспроизведения, система может распознать собственный голос как пользовательский ввод (feedback loop).

**Решение:** Автоматическая пауза распознавания речи на время TTS воспроизведения.

## Архитектура

### Компоненты системы

```
┌─────────────────────────────────────────────────────────┐
│              Settings Panel (Story 1.7)                 │
│  Voice Selection: [Mac System Voice ▼]                  │
│                   [Browser Voice: Samantha ▼]           │
└─────────────────────────────────────────────────────────┘
                            ↓
                    (selected voice)
                            ↓
┌─────────────────────────────────────────────────────────┐
│                  MCP Server (unified-server.ts)         │
│  SSE: speak event → { type: 'speak', text: '...' }      │
└─────────────────────────────────────────────────────────┘
                            ↓
                   (SSE event stream)
                            ↓
┌─────────────────────────────────────────────────────────┐
│           Electron Main Process (MCPIntegration)        │
│  - Получает SSE события                                 │
│  - Отправляет в Renderer: voice:state-changed           │
└─────────────────────────────────────────────────────────┘
                            ↓
                  (IPC: voice:state-changed)
                            ↓
┌─────────────────────────────────────────────────────────┐
│          Electron Renderer (TTSManager - new)           │
│  - TTS Queue (FIFO)                                     │
│  - Voice Selection Router                               │
│  - Mic Pause Controller                                 │
└─────────────────────────────────────────────────────────┘
           ↓                           ↓
   (Mac System Voice)          (Browser Voice)
           ↓                           ↓
┌──────────────────┐        ┌──────────────────┐
│  SystemTTS       │        │  BrowserTTS      │
│  (say command)   │        │  (Web Speech)    │
└──────────────────┘        └──────────────────┘
```

## Технический дизайн

### 1. TTSManager (новый компонент)

**Файл:** `electron/renderer/tts/tts-manager.ts`

```typescript
import type { VoiceSettings } from '../preload/types';

export interface TTSQueueItem {
  id: string;
  text: string;
  timestamp: number;
  voice: VoiceSettings;
}

export type TTSEngine = 'system' | 'browser';

export class TTSManager {
  private queue: TTSQueueItem[] = [];
  private isPlaying = false;
  private currentVoice: VoiceSettings;
  private speechManager: SpeechManager; // Для управления микрофоном

  constructor(speechManager: SpeechManager) {
    this.speechManager = speechManager;
    this.currentVoice = this.loadVoiceSettings();

    // Подписываемся на изменения настроек голоса
    window.electronAPI.settings.onChange((settings) => {
      this.currentVoice = settings.voice;
    });
  }

  /**
   * Добавить текст в очередь TTS
   */
  async enqueue(text: string): Promise<void> {
    const item: TTSQueueItem = {
      id: crypto.randomUUID(),
      text,
      timestamp: Date.now(),
      voice: this.currentVoice,
    };

    this.queue.push(item);
    console.log('[TTS] Enqueued:', item.id, text.substring(0, 50));

    // Если не воспроизводим, начинаем
    if (!this.isPlaying) {
      await this.processQueue();
    }
  }

  /**
   * Обработка очереди TTS (FIFO)
   */
  private async processQueue(): Promise<void> {
    if (this.queue.length === 0) {
      this.isPlaying = false;
      return;
    }

    this.isPlaying = true;
    const item = this.queue.shift()!;

    console.log('[TTS] Playing:', item.id);

    // Пауза микрофона на время TTS
    const wasMicActive = this.speechManager.isListening();
    if (wasMicActive) {
      console.log('[TTS] Pausing microphone');
      this.speechManager.pauseRecognition();
    }

    try {
      // Выбираем TTS engine на основе настроек
      const engine = this.getEngine(item.voice);

      if (engine === 'system') {
        await this.playSystemTTS(item);
      } else {
        await this.playBrowserTTS(item);
      }
    } catch (error) {
      console.error('[TTS] Playback error:', error);
    } finally {
      // Возобновляем микрофон после TTS
      if (wasMicActive) {
        console.log('[TTS] Resuming microphone');
        this.speechManager.resumeRecognition();
      }

      // Продолжаем обработку очереди
      await this.processQueue();
    }
  }

  /**
   * Определяет TTS engine на основе выбранного голоса
   */
  private getEngine(voice: VoiceSettings): TTSEngine {
    // Если выбран "Mac System Voice", используем system TTS
    if (voice.type === 'system') {
      return 'system';
    }

    // Иначе используем browser TTS
    return 'browser';
  }

  /**
   * Воспроизведение через macOS say command
   */
  private async playSystemTTS(item: TTSQueueItem): Promise<void> {
    return new Promise((resolve, reject) => {
      // Вызываем IPC для запуска say command в main process
      window.electronAPI.tts.playSystem({
        text: item.text,
        voice: item.voice.name, // Имя системного голоса
        rate: item.voice.rate,
      })
      .then(() => {
        console.log('[TTS] System playback finished:', item.id);
        resolve();
      })
      .catch((error) => {
        console.error('[TTS] System playback error:', error);
        reject(error);
      });
    });
  }

  /**
   * Воспроизведение через Browser Web Speech API
   */
  private async playBrowserTTS(item: TTSQueueItem): Promise<void> {
    return new Promise((resolve, reject) => {
      const utterance = new SpeechSynthesisUtterance(item.text);

      // Применяем настройки голоса
      utterance.voice = this.getBrowserVoice(item.voice.name);
      utterance.rate = item.voice.rate;
      utterance.volume = item.voice.volume;
      utterance.lang = item.voice.lang || 'ru-RU';

      utterance.onend = () => {
        console.log('[TTS] Browser playback finished:', item.id);
        resolve();
      };

      utterance.onerror = (event) => {
        console.error('[TTS] Browser playback error:', event);
        reject(event);
      };

      window.speechSynthesis.speak(utterance);
    });
  }

  /**
   * Получить browser voice по имени
   */
  private getBrowserVoice(voiceName: string): SpeechSynthesisVoice | null {
    const voices = window.speechSynthesis.getVoices();
    return voices.find(v => v.name === voiceName) || null;
  }

  /**
   * Загрузить настройки голоса из settings
   */
  private loadVoiceSettings(): VoiceSettings {
    // Синхронная версия для constructor
    // Реальная загрузка через onChange callback
    return {
      type: 'system',
      name: 'Samantha', // Default macOS voice
      rate: 1.0,
      volume: 1.0,
      lang: 'ru-RU',
    };
  }

  /**
   * Очистить очередь TTS
   */
  clearQueue(): void {
    this.queue = [];
    window.speechSynthesis.cancel(); // Остановить browser TTS
    console.log('[TTS] Queue cleared');
  }

  /**
   * Получить размер очереди
   */
  getQueueSize(): number {
    return this.queue.length;
  }
}
```

### 2. SpeechManager расширения

**Файл:** `electron/renderer/speech/speech-manager.ts`

```typescript
export class SpeechManager {
  // Existing properties...
  private recognitionPaused = false;

  /**
   * Приостановить распознавание речи (без остановки)
   */
  pauseRecognition(): void {
    if (this.recognition && this.isRecognizing && !this.recognitionPaused) {
      console.log('[Speech] Pausing recognition');
      this.recognition.stop();
      this.recognitionPaused = true;
    }
  }

  /**
   * Возобновить распознавание речи
   */
  resumeRecognition(): void {
    if (this.recognition && this.recognitionPaused) {
      console.log('[Speech] Resuming recognition');
      this.recognition.start();
      this.recognitionPaused = false;
    }
  }

  /**
   * Проверка активности распознавания
   */
  isListening(): boolean {
    return this.isRecognizing && !this.recognitionPaused;
  }
}
```

### 3. Main Process: System TTS

**Файл:** `electron/main/system-tts.ts`

```typescript
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

export interface SystemTTSOptions {
  text: string;
  voice?: string;  // e.g., 'Samantha', 'Yuri'
  rate?: number;   // 0.5 - 2.0
}

export class SystemTTS {
  /**
   * Воспроизвести текст через macOS say command
   */
  static async speak(options: SystemTTSOptions): Promise<void> {
    const { text, voice = 'Samantha', rate = 1.0 } = options;

    // Построить команду say
    const safeText = text.replace(/"/g, '\\"'); // Escape quotes
    const rateWords = Math.round(175 * rate); // 175 words/min = 1.0x rate

    const command = `say -v "${voice}" -r ${rateWords} "${safeText}"`;

    console.log('[SystemTTS] Executing:', command);

    try {
      await execAsync(command);
      console.log('[SystemTTS] Playback finished');
    } catch (error) {
      console.error('[SystemTTS] Error:', error);
      throw error;
    }
  }

  /**
   * Получить список доступных системных голосов
   */
  static async getVoices(): Promise<string[]> {
    try {
      const { stdout } = await execAsync('say -v ?');

      // Парсим вывод say -v ?
      // Формат: "Samantha             en_US    # Hello, my name is Samantha..."
      const voices = stdout
        .split('\n')
        .filter(line => line.trim())
        .map(line => {
          const match = line.match(/^(\S+)/);
          return match ? match[1] : null;
        })
        .filter(Boolean) as string[];

      return voices;
    } catch (error) {
      console.error('[SystemTTS] Failed to get voices:', error);
      return ['Samantha']; // Fallback
    }
  }
}
```

### 4. IPC Handlers для System TTS

**Файл:** `electron/main/index.ts`

```typescript
import { ipcMain } from 'electron';
import { SystemTTS } from './system-tts';

// IPC Handlers для TTS
ipcMain.handle('tts:play-system', async (_event, options: SystemTTSOptions) => {
  try {
    await SystemTTS.speak(options);
    return { success: true };
  } catch (error) {
    console.error('[IPC] tts:play-system error:', error);
    return { success: false, error: String(error) };
  }
});

ipcMain.handle('tts:get-system-voices', async () => {
  try {
    const voices = await SystemTTS.getVoices();
    return { success: true, voices };
  } catch (error) {
    console.error('[IPC] tts:get-system-voices error:', error);
    return { success: false, error: String(error), voices: ['Samantha'] };
  }
});
```

### 5. Preload API расширения

**Файл:** `electron/preload/index.ts`

```typescript
import type { SystemTTSOptions } from '../main/system-tts';

export const electronAPI = {
  // Existing APIs...

  tts: {
    playSystem: (options: SystemTTSOptions) =>
      ipcRenderer.invoke('tts:play-system', options),

    getSystemVoices: () =>
      ipcRenderer.invoke('tts:get-system-voices'),
  },
};
```

### 6. Settings Schema расширение

**Файл:** `electron/main/window-manager.ts`

```typescript
import Store from 'electron-store';

interface VoiceSettings {
  type: 'system' | 'browser';
  name: string;     // Voice name (e.g., 'Samantha' for system, 'Google русский' for browser)
  rate: number;     // 0.5 - 2.0
  volume: number;   // 0.0 - 1.0
  lang: string;     // e.g., 'ru-RU', 'en-US'
}

interface AppSettings {
  // Existing settings...

  // TTS Settings (расширено)
  voice: VoiceSettings;
}

const schema = {
  // Existing schema...

  voice: {
    type: 'object',
    properties: {
      type: { type: 'string', enum: ['system', 'browser'], default: 'system' },
      name: { type: 'string', default: 'Samantha' },
      rate: { type: 'number', minimum: 0.5, maximum: 2.0, default: 1.0 },
      volume: { type: 'number', minimum: 0, maximum: 1, default: 1.0 },
      lang: { type: 'string', default: 'ru-RU' },
    },
    default: {
      type: 'system',
      name: 'Samantha',
      rate: 1.0,
      volume: 1.0,
      lang: 'ru-RU',
    }
  },
};
```

### 7. Settings UI обновление

**Файл:** `electron/renderer/settings.html`

```html
<!-- TTS Settings Section (заменяет старую секцию) -->
<section class="settings-section">
  <h2>Text-to-Speech</h2>

  <!-- Voice Selection -->
  <label>
    Voice:
    <select id="voiceSelect">
      <!-- System voices -->
      <optgroup label="Mac System Voices">
        <option value="system:Samantha">Samantha (US English)</option>
        <option value="system:Yuri">Yuri (Russian)</option>
        <!-- Динамически загружаются через IPC -->
      </optgroup>

      <!-- Browser voices -->
      <optgroup label="Browser Voices (Local)">
        <option value="browser:Google русский">Google русский</option>
        <!-- Динамически загружаются через Web Speech API -->
      </optgroup>

      <optgroup label="Browser Voices (Cloud)">
        <option value="browser:Google US English">Google US English</option>
        <!-- Динамически загружаются через Web Speech API -->
      </optgroup>
    </select>
  </label>

  <!-- Rate Slider -->
  <label>
    Speed: <span id="rateValue">1.0x</span>
    <input type="range" id="rateSlider"
           min="50" max="200" value="100" step="10">
    <input type="number" id="rateInput"
           min="0.5" max="2.0" value="1.0" step="0.1">
  </label>

  <!-- Volume Slider (только для browser TTS) -->
  <label id="volumeLabel">
    Volume: <span id="volumeValue">100%</span>
    <input type="range" id="volumeSlider"
           min="0" max="100" value="100" step="5">
    <input type="number" id="volumeInput"
           min="0" max="1" value="1.0" step="0.1">
  </label>
</section>
```

**Файл:** `electron/renderer/settings.ts`

```typescript
class SettingsUI {
  private elements: {
    voiceSelect: HTMLSelectElement;
    rateSlider: HTMLInputElement;
    rateInput: HTMLInputElement;
    volumeSlider: HTMLInputElement;
    volumeInput: HTMLInputElement;
    volumeLabel: HTMLElement;
  };

  async initialize() {
    this.initializeElements();
    await this.loadVoices();
    await this.loadSettings();
    this.attachEventListeners();
  }

  /**
   * Загрузить доступные голоса (system + browser)
   */
  private async loadVoices() {
    // System voices
    const { voices: systemVoices } = await window.electronAPI.tts.getSystemVoices();
    const systemGroup = this.elements.voiceSelect.querySelector('optgroup[label="Mac System Voices"]');
    systemVoices.forEach(voice => {
      const option = document.createElement('option');
      option.value = `system:${voice}`;
      option.textContent = voice;
      systemGroup?.appendChild(option);
    });

    // Browser voices
    const browserVoices = window.speechSynthesis.getVoices();
    const localGroup = this.elements.voiceSelect.querySelector('optgroup[label="Browser Voices (Local)"]');
    const cloudGroup = this.elements.voiceSelect.querySelector('optgroup[label="Browser Voices (Cloud)"]');

    browserVoices.forEach(voice => {
      const option = document.createElement('option');
      option.value = `browser:${voice.name}`;
      option.textContent = voice.name;

      // Разделяем на local и cloud на основе localService
      if (voice.localService) {
        localGroup?.appendChild(option);
      } else {
        cloudGroup?.appendChild(option);
      }
    });
  }

  private attachEventListeners() {
    // Voice selection change
    this.elements.voiceSelect.addEventListener('change', () => {
      const value = this.elements.voiceSelect.value;
      const [type, name] = value.split(':');

      // Скрываем volume для system TTS (say не поддерживает volume)
      if (type === 'system') {
        this.elements.volumeLabel.style.display = 'none';
      } else {
        this.elements.volumeLabel.style.display = 'block';
      }

      this.saveSettings();
    });

    // Другие event listeners...
  }

  private async saveSettings() {
    const value = this.elements.voiceSelect.value;
    const [type, name] = value.split(':');

    const settings = {
      voice: {
        type: type as 'system' | 'browser',
        name,
        rate: parseFloat(this.elements.rateInput.value),
        volume: parseFloat(this.elements.volumeInput.value),
        lang: 'ru-RU', // TODO: Добавить в UI
      }
    };

    await window.electronAPI.settings.set(settings);
  }
}
```

### 8. Интеграция TTSManager в Main Renderer

**Файл:** `electron/renderer/main.ts`

```typescript
import { TTSManager } from './tts/tts-manager';
import { SpeechManager } from './speech/speech-manager';
import { SpeechUI } from './speech/speech-ui';
import { StateIndicator } from './components/StateIndicator';
import type { VoiceState } from '../preload/types';

// Initialize components
const stateIndicator = new StateIndicator();
const speechUI = new SpeechUI(stateIndicator);
const speechManager = new SpeechManager(speechUI);
const ttsManager = new TTSManager(speechManager);

// Listen for voice state changes from main process (SSE events)
window.electron.onVoiceStateChanged((state: VoiceState) => {
  console.log('[Renderer] Voice state changed:', state);

  // Update UI based on state
  switch (state.state) {
    case 'processing':
      if (state.metadata?.ttsText) {
        // TTS event received - добавляем в очередь
        ttsManager.enqueue(state.metadata.ttsText);
      }
      stateIndicator.setState('processing');
      break;

    // Other cases...
  }
});
```

## План реализации (TDD)

### Phase 1: System TTS Integration (Day 1)
1. ✅ Создать `system-tts.ts` с `speak()` и `getVoices()`
2. ✅ Unit тесты для `SystemTTS.speak()`
3. ✅ IPC handlers: `tts:play-system`, `tts:get-system-voices`
4. ✅ Preload API расширение
5. ✅ Manual test: вызвать system TTS из renderer

### Phase 2: TTSManager & Queue (Day 2)
1. ✅ Создать `tts-manager.ts`
2. ✅ Реализовать FIFO queue
3. ✅ Unit тесты для queue management
4. ✅ Integration test: несколько TTS событий подряд

### Phase 3: Voice Deduplication (Day 3)
1. ✅ Расширить Settings Schema: `voice: VoiceSettings`
2. ✅ Обновить Settings UI: unified voice selection
3. ✅ Реализовать `getEngine()` в TTSManager
4. ✅ Тесты: voice routing (system vs browser)

### Phase 4: Microphone Pause (Day 4)
1. ✅ Добавить `pauseRecognition()` и `resumeRecognition()` в SpeechManager
2. ✅ Интегрировать pause/resume в TTSManager
3. ✅ Тесты: mic pause во время TTS
4. ✅ E2E test: говорить → TTS → mic resume

### Phase 5: Polish & Testing (Day 5)
1. ✅ Error handling для say command failures
2. ✅ Fallback на browser TTS если system TTS недоступен
3. ✅ UI indicators: TTS queue size
4. ✅ Final integration testing
5. ✅ Performance validation

## Тестирование

### Unit Tests

```typescript
// electron/main/__tests__/system-tts.test.ts
describe('SystemTTS', () => {
  it('should speak text via say command', async () => {
    await SystemTTS.speak({
      text: 'Hello world',
      voice: 'Samantha',
      rate: 1.0,
    });

    // Verify say command executed
  });

  it('should get list of system voices', async () => {
    const voices = await SystemTTS.getVoices();
    expect(voices).toContain('Samantha');
  });
});

// electron/renderer/__tests__/tts-manager.test.ts
describe('TTSManager', () => {
  it('should enqueue TTS items in FIFO order', async () => {
    const manager = new TTSManager(mockSpeechManager);

    await manager.enqueue('First');
    await manager.enqueue('Second');

    expect(manager.getQueueSize()).toBe(2);
  });

  it('should pause microphone during TTS', async () => {
    const mockSpeechManager = {
      isListening: () => true,
      pauseRecognition: jest.fn(),
      resumeRecognition: jest.fn(),
    };

    const manager = new TTSManager(mockSpeechManager as any);
    await manager.enqueue('Test');

    // Wait for playback
    await new Promise(resolve => setTimeout(resolve, 100));

    expect(mockSpeechManager.pauseRecognition).toHaveBeenCalled();
    expect(mockSpeechManager.resumeRecognition).toHaveBeenCalled();
  });

  it('should route to correct TTS engine', () => {
    const manager = new TTSManager(mockSpeechManager);

    // System voice
    const systemEngine = manager['getEngine']({
      type: 'system',
      name: 'Samantha',
      rate: 1.0,
      volume: 1.0,
      lang: 'en-US',
    });
    expect(systemEngine).toBe('system');

    // Browser voice
    const browserEngine = manager['getEngine']({
      type: 'browser',
      name: 'Google русский',
      rate: 1.0,
      volume: 1.0,
      lang: 'ru-RU',
    });
    expect(browserEngine).toBe('browser');
  });
});
```

### Integration Tests

```bash
# Development
npm run electron:dev

# Unit tests
npm test -- --testPathPattern=tts

# Manual test: TTS playback
# 1. Open overlay
# 2. Open settings
# 3. Select "Mac System Voice"
# 4. Trigger TTS event (speak something via Claude)
# 5. Verify:
#    - System TTS plays
#    - Microphone pauses during TTS
#    - Microphone resumes after TTS
#    - No voice duplication
```

## Acceptance Criteria

✅ **System TTS Integration:**
- [ ] macOS `say` command запускается из Electron
- [ ] Список системных голосов загружается динамически
- [ ] Rate parameter корректно применяется

✅ **TTS Queue Management:**
- [ ] FIFO очередь работает корректно
- [ ] Множественные TTS события воспроизводятся последовательно
- [ ] Очередь может быть очищена (clearQueue)

✅ **Voice Deduplication:**
- [ ] Только один TTS engine активен в один момент времени
- [ ] Выбор голоса в Settings Panel управляет routing
- [ ] Нет дублирования голосового вывода

✅ **Microphone Pause:**
- [ ] Микрофон автоматически паузится перед TTS
- [ ] Микрофон возобновляется после завершения TTS
- [ ] Нет feedback loop (система не слышит саму себя)

✅ **Settings Integration:**
- [ ] Voice selection dropdown объединяет system и browser голоса
- [ ] Volume slider скрыт для system TTS (не поддерживается)
- [ ] Rate slider работает для обоих TTS engines
- [ ] Настройки сохраняются через electron-store

✅ **Testing:**
- [ ] Unit tests для SystemTTS
- [ ] Unit tests для TTSManager
- [ ] Integration tests для queue management
- [ ] E2E tests для mic pause/resume

## Риски и митигация

### Риск 1: say command не работает на Windows/Linux
**Проблема:** macOS `say` command не существует на других платформах.

**Митигация:**
- Phase 1 фокус на macOS (основная платформа)
- Future: добавить espeak (Linux) и SAPI (Windows)
- Fallback на browser TTS если system TTS недоступен

### Риск 2: TTS queue блокирует UI
**Проблема:** Длинные TTS воспроизведения могут заблокировать очередь.

**Митигация:**
- `clearQueue()` метод для экстренной остановки
- UI indicator для размера очереди
- Timeout для слишком долгих TTS (30s max)

### Риск 3: Microphone не возобновляется после TTS
**Проблема:** Ошибка в TTS может привести к "зависанию" паузы микрофона.

**Митигация:**
- `finally` блок в `processQueue()` для гарантии resume
- Watchdog timer: auto-resume через 30s если TTS не завершился
- Manual resume кнопка в UI

## Следующие шаги (Story 1.9)

После завершения Story 1.8:
1. **Cross-platform TTS** - Поддержка Windows (SAPI) и Linux (espeak)
2. **Advanced Queue Controls** - Pause, Skip, Priority queue
3. **Voice Cloning** - Интеграция с ElevenLabs или Play.ht

## Резюме

Story 1.8 решает три критические проблемы TTS системы:

1. **Voice Deduplication** через unified voice selection
2. **TTS Queue Management** для последовательного воспроизведения
3. **Microphone Pause** для предотвращения feedback loop

Это значительно улучшает качество голосового взаимодействия и делает систему более надёжной.
