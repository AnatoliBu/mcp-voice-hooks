# Story 1.7: Settings Panel

## Цель
Создать отдельное окно настроек (Settings Panel) с постоянным хранилищем для пользовательских предпочтений: язык распознавания, режим отправки, триггер-слово, громкость и скорость речи.

## Контекст
- **Зависимости:** Story 1.6 (MCP Server Integration)
- **Effort:** M (3-5 дней)
- **Сложность:** ⭐⭐ (2/5)

## Архитектура

### Два окна в системе
1. **Overlay Window** (уже существует)
   - Размер: 300x60px
   - Позиция: правый верхний угол экрана
   - Click-through с интерактивными регионами
   - Функционал: drag handle, pin button, state indicator

2. **Settings Window** (новое)
   - Размер: 300x500px
   - Позиция: рядом с overlay (слева или снизу)
   - Модальное поведение: скрывается при клике вне окна
   - Обычное окно (не click-through)

### Persistent Storage с electron-store

```typescript
interface AppSettings {
  // Speech Recognition
  language: string; // 'en-US', 'ru-RU', etc.

  // Send Mode
  sendMode: 'auto' | 'trigger-word';
  triggerWord: string; // default: 'send'

  // TTS Settings
  volume: number; // 0.0 - 1.0
  rate: number;   // 0.5 - 2.0

  // UI Preferences
  theme?: 'light' | 'dark'; // future
}
```

## Технический дизайн

### 1. Расширение WindowManager

**Файл:** `electron/main/window-manager.ts`

```typescript
export class WindowManager {
  private overlayWindow: BrowserWindow;
  private settingsWindow: BrowserWindow | null = null;
  private store: Store<AppSettings>;

  // Новые методы
  public createSettingsWindow(): void;
  public toggleSettingsWindow(): void;
  private positionSettingsWindow(): void;

  // IPC handlers
  private setupSettingsIpcHandlers(): void;
}
```

**Ключевые особенности:**
- Lazy creation: settings window создаётся при первом вызове
- Auto-positioning относительно overlay window
- Auto-hide при потере фокуса (опционально)

### 2. electron-store Integration

**Установка:**
```bash
npm install electron-store
```

**Использование:**
```typescript
import Store from 'electron-store';

const schema = {
  language: { type: 'string', default: 'en-US' },
  sendMode: { type: 'string', enum: ['auto', 'trigger-word'], default: 'auto' },
  triggerWord: { type: 'string', default: 'send' },
  volume: { type: 'number', minimum: 0, maximum: 1, default: 1.0 },
  rate: { type: 'number', minimum: 0.5, maximum: 2.0, default: 1.0 }
};

this.store = new Store<AppSettings>({ schema });
```

### 3. Settings Window UI

**Файл:** `electron/renderer/settings.html`

```html
<!DOCTYPE html>
<html>
<head>
  <title>MCP Voice Hooks - Settings</title>
  <link rel="stylesheet" href="settings.css">
</head>
<body>
  <div class="settings-container">
    <h1>Settings</h1>

    <!-- Language Selection -->
    <section class="settings-section">
      <h2>Speech Recognition</h2>
      <label>
        Language:
        <select id="languageSelect">
          <option value="en-US">English (US)</option>
          <option value="ru-RU">Русский</option>
          <!-- More languages -->
        </select>
      </label>
    </section>

    <!-- Send Mode -->
    <section class="settings-section">
      <h2>Send Mode</h2>
      <label>
        <input type="radio" name="sendMode" value="auto" checked>
        Auto-send on pause
      </label>
      <label>
        <input type="radio" name="sendMode" value="trigger-word">
        Wait for trigger word
      </label>

      <div id="triggerWordSettings" style="display: none;">
        <label>
          Trigger word:
          <input type="text" id="triggerWordInput" placeholder="send">
        </label>
      </div>
    </section>

    <!-- TTS Settings -->
    <section class="settings-section">
      <h2>Text-to-Speech</h2>

      <label>
        Volume: <span id="volumeValue">100%</span>
        <input type="range" id="volumeSlider"
               min="0" max="100" value="100" step="5">
      </label>

      <label>
        Speed: <span id="rateValue">1.0x</span>
        <input type="range" id="rateSlider"
               min="50" max="200" value="100" step="10">
      </label>
    </section>

    <!-- Footer -->
    <div class="settings-footer">
      <button id="resetBtn" class="btn-secondary">Reset to Defaults</button>
      <button id="closeBtn" class="btn-primary">Close</button>
    </div>
  </div>

  <script src="settings.js"></script>
</body>
</html>
```

**Файл:** `electron/renderer/settings.ts`

```typescript
// Settings UI Controller
class SettingsUI {
  private elements: {
    languageSelect: HTMLSelectElement;
    sendModeRadios: NodeListOf<HTMLInputElement>;
    triggerWordInput: HTMLInputElement;
    volumeSlider: HTMLInputElement;
    rateSlider: HTMLInputElement;
    // ...
  };

  constructor() {
    this.initializeElements();
    this.loadSettings();
    this.attachEventListeners();
  }

  private async loadSettings() {
    const settings = await window.electronAPI.settings.get();
    // Populate UI with current settings
  }

  private async saveSettings() {
    const settings = this.collectSettings();
    await window.electronAPI.settings.set(settings);
  }

  private collectSettings(): AppSettings {
    return {
      language: this.elements.languageSelect.value,
      sendMode: /* ... */,
      triggerWord: /* ... */,
      volume: parseFloat(this.elements.volumeSlider.value) / 100,
      rate: parseFloat(this.elements.rateSlider.value) / 100,
    };
  }
}
```

### 4. IPC API для Settings

**Файл:** `electron/preload/index.ts`

```typescript
export const electronAPI = {
  // Existing APIs...

  settings: {
    get: () => ipcRenderer.invoke('settings:get'),
    set: (settings: Partial<AppSettings>) =>
      ipcRenderer.invoke('settings:set', settings),
    reset: () => ipcRenderer.invoke('settings:reset'),

    // Subscribe to settings changes
    onChange: (callback: (settings: AppSettings) => void) => {
      ipcRenderer.on('settings:changed', (_event, settings) => {
        callback(settings);
      });
      return () => ipcRenderer.removeListener('settings:changed', callback);
    }
  },

  window: {
    // Existing methods...
    toggleSettings: () => ipcRenderer.invoke('window:toggle-settings'),
  }
};
```

### 5. Global Hotkey для Settings

**Расширение:** `electron/main/index.ts`

```typescript
import { globalShortcut } from 'electron';

// Регистрация hotkey для открытия настроек
// Cmd+, на macOS, Ctrl+, на Windows/Linux
const settingsShortcut = process.platform === 'darwin'
  ? 'Command+,'
  : 'Control+,';

globalShortcut.register(settingsShortcut, () => {
  windowManager.toggleSettingsWindow();
});
```

### 6. Интеграция с SpeechManager

Настройки должны применяться к SpeechManager в реальном времени:

**Файл:** `electron/renderer/speech/speech-manager.ts`

```typescript
export class SpeechManager {
  constructor(
    private ui: SpeechUI,
    private mcpClient: MCPClient
  ) {
    // Subscribe to settings changes
    window.electronAPI.settings.onChange((settings) => {
      this.applySettings(settings);
    });

    // Load initial settings
    this.loadSettings();
  }

  private async loadSettings() {
    const settings = await window.electronAPI.settings.get();
    this.applySettings(settings);
  }

  private applySettings(settings: AppSettings) {
    // Apply language
    if (this.recognition) {
      this.recognition.lang = settings.language;
    }

    // Apply send mode
    this.sendMode = settings.sendMode;
    this.triggerWord = settings.triggerWord.toLowerCase();

    // TTS settings применяются при speak
    this.ttsVolume = settings.volume;
    this.ttsRate = settings.rate;
  }
}
```

## План реализации (TDD)

### Phase 1: electron-store Integration (Day 1)
1. ✅ Установить electron-store
2. ✅ Создать schema для AppSettings
3. ✅ Добавить store в WindowManager
4. ✅ Написать тесты для settings persistence
5. ✅ Реализовать IPC handlers для get/set/reset

### Phase 2: Settings Window (Day 2)
1. ✅ Создать settings.html с базовой разметкой
2. ✅ Реализовать createSettingsWindow() в WindowManager
3. ✅ Реализовать toggleSettingsWindow()
4. ✅ Реализовать auto-positioning относительно overlay
5. ✅ Тесты для window management

### Phase 3: Settings UI Components (Day 3)
1. ✅ Реализовать SettingsUI controller
2. ✅ Language selection dropdown
3. ✅ Send mode radio buttons с conditional trigger word input
4. ✅ Volume slider с live preview
5. ✅ Rate slider с live preview
6. ✅ Reset to defaults button

### Phase 4: Integration (Day 4)
1. ✅ Интегрировать settings.onChange с SpeechManager
2. ✅ Применять language к Web Speech API
3. ✅ Применять send mode к utterance handling
4. ✅ Применять TTS settings
5. ✅ E2E тесты

### Phase 5: UX Polish (Day 5)
1. ✅ Добавить global hotkey (Cmd+,)
2. ✅ Settings button в overlay UI
3. ✅ Auto-hide settings при потере фокуса
4. ✅ Animations для открытия/закрытия
5. ✅ Финальное тестирование

## Тестирование

### Unit Tests
```typescript
// electron/main/window-manager.test.ts
describe('WindowManager Settings', () => {
  it('should create settings window on first toggle', async () => {
    const wm = new WindowManager(mockOverlayWindow);
    await wm.toggleSettingsWindow();

    expect(wm.settingsWindow).toBeTruthy();
    expect(wm.settingsWindow.isVisible()).toBe(true);
  });

  it('should position settings window next to overlay', () => {
    // ...
  });

  it('should toggle visibility on subsequent calls', async () => {
    const wm = new WindowManager(mockOverlayWindow);

    await wm.toggleSettingsWindow(); // show
    expect(wm.settingsWindow.isVisible()).toBe(true);

    await wm.toggleSettingsWindow(); // hide
    expect(wm.settingsWindow.isVisible()).toBe(false);
  });
});
```

### Integration Tests
```typescript
// electron/renderer/settings.test.ts
describe('Settings UI', () => {
  it('should load current settings on init', async () => {
    const ui = new SettingsUI();
    await ui.initialize();

    const settings = await window.electronAPI.settings.get();
    expect(ui.elements.languageSelect.value).toBe(settings.language);
  });

  it('should save settings on change', async () => {
    const ui = new SettingsUI();

    ui.elements.volumeSlider.value = '80';
    ui.elements.volumeSlider.dispatchEvent(new Event('change'));

    const settings = await window.electronAPI.settings.get();
    expect(settings.volume).toBe(0.8);
  });

  it('should reset to defaults', async () => {
    // Change some settings
    await window.electronAPI.settings.set({ volume: 0.5 });

    const ui = new SettingsUI();
    ui.elements.resetBtn.click();

    const settings = await window.electronAPI.settings.get();
    expect(settings.volume).toBe(1.0); // default
  });
});
```

## Acceptance Criteria

✅ **Settings Window:**
- [ ] Создано отдельное окно 300x500px
- [ ] Открывается/закрывается по Cmd+, (macOS) / Ctrl+, (Windows)
- [ ] Позиционируется рядом с overlay window
- [ ] Скрывается при потере фокуса (опционально)

✅ **Settings Persistence:**
- [ ] Все настройки сохраняются через electron-store
- [ ] Настройки загружаются при старте приложения
- [ ] Изменения применяются в реальном времени

✅ **UI Components:**
- [ ] Language dropdown работает корректно
- [ ] Send mode переключение с conditional trigger word input
- [ ] Volume slider с live update
- [ ] Rate slider с live update
- [ ] Reset to defaults восстанавливает значения по умолчанию

✅ **Integration:**
- [ ] Language применяется к Web Speech API
- [ ] Send mode меняет поведение utterance handling
- [ ] TTS settings применяются к речи
- [ ] Все изменения отражаются без перезапуска

✅ **Testing:**
- [ ] Unit tests для WindowManager settings methods
- [ ] Unit tests для SettingsUI
- [ ] Integration tests для IPC communication
- [ ] E2E tests для полного flow

## Дополнительные замечания

### Future Enhancements (не в текущем scope)
- Theme selection (light/dark)
- Custom hotkey configuration
- Voice selection для TTS
- Export/Import settings
- Settings sync между устройствами

### Known Issues
- electron-store не поддерживает live reload в dev mode (требуется перезапуск)
- Auto-hide может конфликтовать с некоторыми window managers на Linux

### Dependencies
```json
{
  "dependencies": {
    "electron-store": "^10.0.0"
  },
  "devDependencies": {
    "@types/electron-store": "^3.2.0"
  }
}
```

## Резюме
Story 1.7 добавляет полноценное окно настроек с persistent storage, позволяя пользователям настроить язык распознавания, режим отправки, триггер-слово и TTS параметры. Это значительно улучшает UX и делает приложение более гибким для разных языков и workflow.
